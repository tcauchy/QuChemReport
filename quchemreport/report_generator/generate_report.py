import json
import os
import re
from collections import defaultdict
import numpy as np
from pylatex import Document, Section, MultiColumn,LargeText, Tabular, LongTable
from pylatex.utils import italic, bold, NoEscape, escape_latex
from pylatex.package import Package
from cclib.parser.utils import PeriodicTable

from quchemreport.config.config import Config, OutputInclude
from quchemreport.utility_services.computed_data import ComputedData
from quchemreport.utility_services.parameters import THRESHOLD_IR_INTENSITIES
from quchemreport.utility_services.units import nm_to_wnb

# TODO : NEED TO THINK ABOUT THE MAX VALUE
MAX_NUMBER_OF_ATOMS_TO_DISPLAY_ATOMIC_COORDINATE_REF_ABOVE = 15

def add_row_filter(tab, l, expr='N/A'):
    if (
        ((l[1].__class__ != tuple) and (l[1] != expr)) # case 1
        or ((l[1].__class__ == tuple) and np.all([elt != expr for elt in l[1]])) # case 2
    ): 
        ## case 1 : value is not a tuple AND is not expr (eg. N/A)
        ## case 2 : value is a tuple AND ALL values are different from expr (eg. N/A)
        tab.add_row(l)


def figure_one_col(doc, nomPng, taillePng="7cm", caption="Figure", escapeCaption=True):
    if escapeCaption:
        caption = escape_latex(caption)
    
    doc.append(NoEscape(r'\begin{figure}[H]'))
    doc.append(NoEscape(r'\begin{center}'))
    doc.append(NoEscape(r'\includegraphics[width='+taillePng+']{'+nomPng+'}'))
    doc.append(NoEscape(r'\end{center}'))
    doc.append(NoEscape(r'\vspace{-5mm}'))
    doc.append(NoEscape(r'\caption{' + caption + '}'))
    doc.append(NoEscape(r'\end{figure}'))


def figure_two_col(doc, nomPng, nomPng2, taillePng="7cm", caption="Figure", escapeCaption=True):
    if escapeCaption:
        caption = escape_latex(caption)
    
    doc.append(NoEscape(r'\begin{figure}[H]'))
    doc.append(NoEscape(r'\begin{center}'))
    doc.append(NoEscape(r'\includegraphics[width='+taillePng+']{'+nomPng+'}'))
    doc.append(NoEscape(r'\includegraphics[width='+taillePng+']{'+nomPng2+'}'))
    doc.append(NoEscape(r'\end{center}'))
    doc.append(NoEscape(r'\vspace{-5mm}'))
    doc.append(NoEscape(r'\caption{' + caption + '}'))
    doc.append(NoEscape(r'\end{figure}'))


def sanitize_filename(name: str) -> str:
    return re.sub(r'[^A-Za-z0-9_-]+', '_', name)


def generate_empty_document(report_type):
    #####################################################################
    #                                                                   #
    ## production du rapport en .tex                                 #
    #                                                                   #
    #####################################################################
    
    ### create document and import needed packages
    
    doc = Document(documentclass="article",font_size='small',geometry_options='a4paper, left=15mm, right=15mm, top=15mm, bottom=15mm')
    # packages
    doc.packages.append(NoEscape(r'\usepackage{xcolor}'))
    doc.packages.append(NoEscape(r'\usepackage{longtable}'))
    doc.packages.append(NoEscape(r'\usepackage{graphicx}'))
    
    # Add 'float' to force figures at exact positions with [H].
    # If space is lacking, LaTeX moves them to the next page, preserving order.
    doc.packages.append(NoEscape(r'\usepackage{float}'))
    doc.packages.append(NoEscape(r'\usepackage{placeins}'))
    
    # For full report, definition of an original layout. 
    if report_type == 'full': 
        doc.packages.append(NoEscape(r'\usepackage{titlesec}'))
        doc.packages.append(Package('datetime'))
        doc.packages.append(NoEscape(r'\usepackage{extramarks}'))
        doc.packages.append(NoEscape(r'\usepackage{fancyhdr}'))
        doc.packages.append(NoEscape(r'\pagestyle{fancy}'))
        doc.packages.append(NoEscape(r'\fancyhf{}'))
        # define header / footer texts
        doc.packages.append(NoEscape(r'\lhead{MOLECULAR CALCULATION REPORT}'))
        doc.packages.append(NoEscape(r'\rhead{Generated by quchemreport}'))
        doc.packages.append(NoEscape(r'\lfoot{\today ~  \currenttime}'))
        doc.packages.append(NoEscape(r'\rfoot{Page \thepage}'))
        doc.packages.append(NoEscape(r'\cfoot{}'))
        # redefine rules for header / footer
        doc.packages.append(NoEscape(r'\renewcommand\headrulewidth{0.4pt}'))
        doc.packages.append(NoEscape(r'\renewcommand\footrulewidth{0.4pt}'))
        # redefine section
        doc.packages.append(NoEscape(r'\definecolor{ufrblue}{RGB}{0,161,140}'))
        doc.packages.append(NoEscape(r'\definecolor{bordeau}{RGB}{125,31,31}'))
        doc.packages.append(NoEscape(r'\titleformat{name=\section}[block]{\sc\large}{}{0pt}{\colorsection}'))
        doc.packages.append(NoEscape(r'\titlespacing{\section}{0pt}{\baselineskip}{2pt}'))
        doc.packages.append(NoEscape(r'\titlespacing{\subsection}{4pt}{\baselineskip}{0pt}'))
        doc.packages.append(NoEscape(r'\newcommand{\colorsection}[1]{'
                                        +r'\colorbox{ufrblue}{\parbox{\dimexpr\textwidth-2\fboxsep}{\textcolor{white}{'
                                        +r'\textbf{{\thesection.\ #1}}}}}}'))
        
    # For non full report, definition of a simple Title. 
    # SI mode is more suitable to conversion to word for supp Info generation. 
    if report_type != 'full': 
        doc.append(NoEscape(r'\begin{center}'))
        doc.append(LargeText(bold("Molecular Calculation Report generated by quchemreport \n")))
        doc.append(NoEscape(r'\today '))
        doc.append(NoEscape(r'\end{center}'))
        
    return doc


def render_ref_molecule_representation(section, output_dir, computed_data: ComputedData):
    ref_id = computed_data.metadata.ref_log_file_idx
    log_file = computed_data.metadata.log_files[ref_id]
    
    nomPng = f"img-log{ref_id+1}-TOPOLOGY.png"
    
    if ( not os.path.isfile(output_dir + nomPng) ):
        print(f"{nomPng} not found. Molecule representation for the reference can not be added to the report.\n")
        return False
    
    figure_one_col(section, nomPng, caption=f"Chemical structure diagram with atomic numbering. (Source: {log_file})")
    
    return True


def render_grouped_values_with_logs(table, label, values, log_files, ref_id, table_col):
    # Regrouper les logs par valeurs équivalentes
    grouped = []  # liste de tuples (valeur, [logs])

    for val, log in zip(values, log_files):
        
        if val is None:
            continue

        # Chercher si une valeur équivalente existe déjà
        for entry in grouped:
            if val == entry[0]:  # comparaison par égalité
                entry[1].append(log)
                break
        else:
            grouped.append([val, [log]])  # nouvelle entrée

    if not grouped:
        return
    
    # Display only a single value if it’s the same across all log files
    if len(grouped) == 1:
        val = grouped[0][0]
        row = [label, f"{val}"]
        row += [''] * (table_col - len(row))
        table.add_row(row)
        return

    ref_value = values[ref_id]
    grouped_entries = []

    # Display the reference value first if present
    if ref_value is not None:
        for val, logs in grouped:
            if val == ref_value:
                log_str = ', '.join(escape_latex(str(log)) for log in logs)
                grouped_entries.append(f"\\textbf{{{val}}} ({log_str})")
                break

    # Add other values
    grouped_entries += [
        f"\\textbf{{{val}}} ({', '.join(escape_latex(str(log)) for log in logs)})"
        for val, logs in grouped
        if val != ref_value
    ]

    # Add row to the table
    row = [label, NoEscape('; '.join(grouped_entries))]
    row += [''] * (table_col - len(row))
    table.add_row(row)
    table.add_row([''] * table_col)


def fill_logfiles_details_section(doc, computed_data, config: Config):
    with doc.create(Section('LOGFILES DETAILS')) :
        
        ref_id = computed_data.metadata.ref_log_file_idx
        log_files = computed_data.metadata.log_files
        job_types = computed_data.comp_details.general.job_type
        
        with doc.create(LongTable("p{0.2\\textwidth} p{0.8\\textwidth}")) as log_table:
            
            # Render a list of log_files and their respective jobtypes
            logfiles_and_jobs = [
                f"{log} [{', '.join(job) if job else 'N/A'}]"
                for log, job in zip(log_files, job_types)
            ]
            log_table.add_row(['Log files', "\n".join(logfiles_and_jobs)])
            
            log_table.add_row(["", ""])
            
            # Render the reference logfile
            log_table.add_row(['Reference Log file', log_files[ref_id]])
            
            # Render the excited state number selected for optmized logfiles
            es_entries = []
            for i, log in enumerate(log_files):
                if any("_es" in jb for jb in job_types[i]):
                    es_number = config.logfiles[i].excited_state_number
                    if es_number is not None:
                        es_entries.append(f"State {es_number} ({log})")
            if es_entries:
                log_table.add_row(["", ""])
                log_table.add_row(['Optimized Excited State', "\n".join(es_entries)])


def render_molecule_identification(section, computed_data: ComputedData, designated_name, report_type):
    
    with section.create(LongTable("p{0.2\\textwidth} p{0.8\\textwidth}")) as mol_table:

        ref_id = computed_data.metadata.ref_log_file_idx
        log_files = computed_data.metadata.log_files
        charges = computed_data.molecule.charges
        multiplicities = computed_data.molecule.multiplicity
        monoisotopic_mass = computed_data.molecule.monoisotopic_mass
        inchi = (computed_data.molecule.inchi).rstrip().split("=")[-1] if computed_data.molecule.inchi else None
        smi = computed_data.molecule.smi
        
        # No data to display
        if (
            log_files is None
            and charges is None
            and multiplicities is None
            and monoisotopic_mass is None
            and inchi is None
            and smi is None
        ):
            return False
        
        # Render the corresponding Designated Name 
        if designated_name:
            mol_table.add_row(['Designated Name', designated_name ])
        
        # Render the corresponding formula (unique value due to uniformity check)
        if computed_data.molecule.formula != None: 
            mol_table.add_row(['Formula', computed_data.molecule.formula])
        
        # group log files by charge if multiple values, and show reference value first
        # otherwise, only display the charge found in the reference
        render_grouped_values_with_logs(mol_table, 'Charges', charges, log_files, ref_id, table_col=2)

        # group log files by multiplicities if multiple values, and show reference value first
        # otherwise, only display the multiplicty found in the reference
        render_grouped_values_with_logs(mol_table, 'Spin multiplicity', multiplicities, log_files, ref_id, table_col=2)
        
        # For full report, more data will be printed 
        if report_type == 'full': 
            if monoisotopic_mass is not None:
                mol_table.add_row(['Monoisotopic mass', "%.5f Da" % monoisotopic_mass])

            if inchi is not None:
                mol_table.add_row(['InChI'  , inchi ])

            # TODO : IS IT BETTER TO JUST TRUNCATE THE SMILES IF TOO LONG ?
            if (
                smi is not None
                and (len(smi) < 80)
            ):
                mol_table.add_row(['SMILES' , smi ])
                
    return True


def render_atomic_coordinates_table(doc, atoms, atoms_Z, log_file: str, table_title: str):
    doc.append(NoEscape(r'\begin{footnotesize}'))
    doc.append(NoEscape(r'\begin{center}'))

    with doc.create(LongTable('p{0.5cm}rrrrp{0.5cm}')) as table:
        table.add_row(
            [MultiColumn(6, align='c', data=table_title)]
        )
        table.add_row(
            [MultiColumn(6, align='l', data=f"Source: {log_file}")]
        )
        table.add_hline()
        table.add_row([
            "",
            MultiColumn(1, align='c', data='Atom'),
            MultiColumn(1, align='c', data='X'),
            MultiColumn(1, align='c', data='Y'),
            MultiColumn(1, align='c', data='Z'),
            ""
        ])
        table.add_hline()

        for j, coord in enumerate(atoms):
            table.add_row([
                "",
                PeriodicTable().element[atoms_Z[j]],
                f"{coord[0]:.4f}",
                f"{coord[1]:.4f}",
                f"{coord[2]:.4f}",
                ""
            ])

        table.add_hline()

    doc.append(NoEscape(r'\end{center}'))
    doc.append(NoEscape(r'\end{footnotesize}'))

def render_ref_atomic_coordinates(section, computed_data: ComputedData):
    ref_id = computed_data.metadata.ref_log_file_idx
    atoms = computed_data.results.geometry.elements_3D_coords[ref_id]
    atoms_Z = computed_data.molecule.atoms_Z[ref_id]
    log_file = computed_data.metadata.log_files[ref_id]

    # Skip if no data
    if (
        atoms is None
        or atoms_Z is None
    ):
        return False

    atoms = np.array(atoms).reshape((-1, 3))

    # If too much atoms, the table will be display at the end of the reports
    if len(atoms) >= MAX_NUMBER_OF_ATOMS_TO_DISPLAY_ATOMIC_COORDINATE_REF_ABOVE:
        return False

    render_atomic_coordinates_table(
        doc=section,
        atoms=atoms,
        atoms_Z=atoms_Z,
        log_file=log_file,
        table_title='Table. Converged cartesian atomic coordinates in Angstroms',
    )
    
    return True

def fill_molecule_section(doc, output_dir, computed_data: ComputedData, designated_name, report_type, config_output: OutputInclude):
    section = Section('MOLECULE')
    
    added_ref_molecule = False
    added_mol_identification = False
    added_atomic_oordinates = False
    
    if config_output.molecule.molecule_representation:
        added_ref_molecule = render_ref_molecule_representation(section, output_dir, computed_data)
    
    # TODO : TO IMPLEMENT : The selection of which informations to display is not done. For now all data available are displayed.
    if len(config_output.molecule.molecule_identification) != 0:
        added_mol_identification = render_molecule_identification(section, computed_data, designated_name, report_type)
        
    if config_output.molecule.atomic_coordinates:
        added_atomic_oordinates = render_ref_atomic_coordinates(section, computed_data)

    if (
        added_ref_molecule
        or added_mol_identification
        or added_atomic_oordinates
    ):
        doc.append(section)


def fill_computational_details_section(doc, computed_data: ComputedData):
    
    with doc.create(Section('COMPUTATIONAL DETAILS')) :
        
        ref_id = computed_data.metadata.ref_log_file_idx
        
        # List with the name of each logfile
        log_files = computed_data.metadata.log_files
        
        # Unique value (string)
        package = computed_data.comp_details.general.package
        
        # All variables below are a list where the index of the value match the index of each logfile
        package_version = computed_data.comp_details.general.package_version
        last_theory = computed_data.comp_details.general.last_theory
        functional = computed_data.comp_details.general.functional
        basis_set_name = computed_data.comp_details.general.basis_set_name
        basis_set_size = computed_data.comp_details.general.basis_set_size
        is_closed_shell = computed_data.comp_details.general.is_closed_shell
        integration_grid = computed_data.comp_details.general.integration_grid
        solvent = computed_data.comp_details.general.solvent
        scf_targets = computed_data.comp_details.general.scf_targets
        geometric_targets = computed_data.comp_details.geometry.geometric_targets
        geometric_values = computed_data.results.geometry.geometric_values
        temperature = computed_data.comp_details.freq.temperature
        anharmonicity = computed_data.comp_details.freq.anharmonicity
        nuclear_repulsion_energy_from_xyz = computed_data.results.geometry.nuclear_repulsion_energy_from_xyz
        nb_et_states = computed_data.comp_details.excited_states.nb_et_states
        et_sym = computed_data.results.excited_states.et_sym
                
        with doc.create(LongTable("p{0.6\\textwidth} p{0.2\\textwidth} p{0.2\\textwidth}")) as param_table :
            software = package
            
            # Unique value
            if (
                package != None
                and package_version[ref_id] != None
            ):
                param_table.add_row(['Software', package, ""] )
            
            render_grouped_values_with_logs(param_table, 'Package Versions', package_version, log_files, ref_id, table_col=3)
            render_grouped_values_with_logs(param_table, 'Computational method', last_theory, log_files, ref_id, table_col=3)
            render_grouped_values_with_logs(param_table, 'Functional', functional, log_files, ref_id, table_col=3)
            render_grouped_values_with_logs(param_table, 'Basis set name', basis_set_name, log_files, ref_id, table_col=3)
            render_grouped_values_with_logs(param_table, 'Number of basis set functions', basis_set_size, log_files, ref_id, table_col=3)
            render_grouped_values_with_logs(param_table, 'Closed shell calculation', is_closed_shell, log_files, ref_id, table_col=3)
            render_grouped_values_with_logs(param_table, 'Integration grid', integration_grid, log_files, ref_id, table_col=3)
            render_grouped_values_with_logs(param_table, 'Solvent', solvent, log_files, ref_id, table_col=3)
            
            # TODO : TO ADD LATER ?
            # add_row_filter(param_table, ['Solvent reaction filed method',  
            #                             list_data_models[i].comp_details.general.solvent_reaction_field])
    
            # TODO : TO CHECK : Complete the transformation for the output of scfTargers here (only from ref file for now)
            scfTargets = scf_targets[-1]
            if software=="gaussian" : # Gaussian or GAUSSIAN (upper/lower?
                param_table.add_row(["Requested SCF convergence on RMS and Max density matrix", scfTargets[ref_id][0], scfTargets[ref_id][1]  ])
                param_table.add_row(["Requested SCF convergence on energy", scfTargets[ref_id][2], " "  ])
            if software=="gamess" :
                param_table.add_row(["Requested SCF convergence on density", scfTargets[ref_id][0], " "   ])
            
            
            param_table.add_row([" ", " " , " "])
            
            
            # Display specific calculations parameters
            ordered_logfiles_indices = [ref_id] + [i for i in range(len(log_files)) if i != ref_id]
            for i in ordered_logfiles_indices:
                log = log_files[i]
                geom_targets = geometric_targets[i]
                geom_values = None
                if geometric_values[i] is not None:
                    geom_values = geometric_values[i][-1]
                temp = temperature[i]
                anh = anharmonicity[i]
                nre_from_xyz = nuclear_repulsion_energy_from_xyz[i]
                nb_states = nb_et_states[i]
                et_sym_i = et_sym[i]
                
                # Skip if no data is available
                if (
                    geom_targets == None
                    and geom_values == None
                    and temp == None
                    and anh == None
                    and nb_states == None
                    and et_sym_i == None
                ):
                    continue
                
                param_table.add_row([f"Logfile : {log}", "", ""])

                # geometric optimization
                if geom_targets is not None and geom_values is not None:
                    if software=="gaussian":
                        param_table.add_row(["Max Force value and threshold", f"{geom_values[0]:.6f}", f"{geom_targets[0]:.6f}"])
                        param_table.add_row(["RMS Force value and threshold", f"{geom_values[1]:.6f}", f"{geom_targets[1]:.6f}"])
                        param_table.add_row(["Max Displacement value and threshold", f"{geom_values[2]:.6f}", f"{geom_targets[2]:.6f}"])
                        param_table.add_row(["RMS Displacement value and threshold", f"{geom_values[3]:.6f}", f"{geom_targets[3]:.6f}"])
                    if software=="gamess" :
                        # in Hartrees per Bohr
                            param_table.add_row(["Max Force value and threshold", geom_values[0] , geom_values[0]])
                            param_table.add_row(["RMS Force value and threshold",  geom_values[1] , geom_values[1]])    
                            
                
                # frequencies / thermochemistry
                if temp is not None:
                    param_table.add_row(["Temperature", f"{temp:.2f} K", ""])
                if anh is not None:
                    param_table.add_row(["Anharmonic effects", f"{anh}", ""])
                if nre_from_xyz is not None:
                    param_table.add_row(['Converged nuclear repulsion energy', f"{nre_from_xyz:.5f} Hartrees", ""])

                # Paramètres états excités
                if nb_states is not None and et_sym_i is not None:
                    unique_syms = np.unique(et_sym_i)
                    param_table.add_row(['Number of calculated excited states and spin state', f"{nb_states}", f"{', '.join(unique_syms)}"])
                    
                param_table.add_row([" ", " ", ""])


def serialize_energies_data(total_energy, homo_ind, MO_energies, MO_labels, MO_indexes):
    return json.dumps({
        "total_energy": total_energy,
        "homo_ind": homo_ind,
        "MO_energies": MO_energies,
        "MO_labels": MO_labels,
        "MO_indexes": MO_indexes,
    }, sort_keys=True)


def render_energies_table(doc, computed_data: ComputedData, log_indexes):
    log_files = computed_data.metadata.log_files
    i_log = log_indexes[0]
    
    total_energy = computed_data.results.wavefunction.total_molecular_energy[i_log]
    homo_ind = computed_data.results.wavefunction.homo_indexes[i_log]
    MO_energies = computed_data.results.wavefunction.MO_energies[i_log]
    MO_labels = computed_data.derived.wavefunction.MO_analysis.MO_labels[i_log]
    MO_indexes = computed_data.derived.wavefunction.MO_analysis.MO_indexes[i_log]

    
    if (
        total_energy is None 
        and (
            MO_energies is None
            or homo_ind is None
            or MO_indexes is None
            or MO_labels is None
        )
    ):
        return

    with doc.create(LongTable("p{0.6\\textwidth} p{0.2\\textwidth} p{0.2\\textwidth}")) as wavefunction_table:
        
        sources = ", ".join([log_files[idx] for idx in log_indexes])
        wavefunction_table.add_row(
            [MultiColumn(3, align='l', data=f"Wavefunction Energies (Sources: {sources})")]
        )
        
        if total_energy is not None:
            wavefunction_table.add_row(['Total molecular energy', "%.5f hartrees" % total_energy, " "])

        if (
            MO_energies is None
            or homo_ind is None
            or MO_indexes is None
            or MO_labels is None
        ):
            return

        if len(homo_ind) == 2:
            wavefunction_table.add_row(['Unrestricted calculation', 'Alpha spin MO', 'Beta spin MO'])
            wavefunction_table.add_row(['HOMO number', homo_ind[0]+1, homo_ind[1]+1])

            for idx_label, _ in enumerate(MO_labels[0]):
                idx_alpha = MO_indexes[0][idx_label]
                idx_beta  = MO_indexes[1][idx_label]
                label = MO_labels[0][idx_label].replace("_alpha", "")

                wavefunction_table.add_row([
                    f"{label.upper()} energies",
                    "%.2f eV" % MO_energies[0][idx_alpha],
                    "%.2f eV" % MO_energies[1][idx_beta]
                ])
        else:
            wavefunction_table.add_row(['Restricted calculation', 'Spin MO', " "])
            wavefunction_table.add_row(['HOMO number', homo_ind[0]+1, " "])

            for idx_label, label in enumerate(MO_labels[0]):
                idx = MO_indexes[0][idx_label]
                wavefunction_table.add_row([
                    f"{label.upper()} energies",
                    "%.2f eV" % MO_energies[0][idx],
                    " "
                ])


def render_energies(section, computed_data: ComputedData):
    n_logs = len(computed_data.results.wavefunction.MO_energies)
    ref_id = computed_data.metadata.ref_log_file_idx
    
    isContentAdded = False

    seen = defaultdict(list)

    for i in range(n_logs):
        total_energy = computed_data.results.wavefunction.total_molecular_energy[i]
        homo_ind = computed_data.results.wavefunction.homo_indexes[i]
        MO_energies = computed_data.results.wavefunction.MO_energies[i]
        MO_labels = computed_data.derived.wavefunction.MO_analysis.MO_labels[i]
        MO_indexes = computed_data.derived.wavefunction.MO_analysis.MO_indexes[i]

        if (
            total_energy is None 
            or homo_ind is None 
            or MO_energies is None
            or MO_labels is None
            or MO_indexes is None
        ):
            continue

        key = serialize_energies_data(total_energy, homo_ind, MO_energies, MO_labels, MO_indexes)
        seen[key].append(i)

    # Find the group of data tha contains the reference
    groups = list(seen.values())
    ref_group = None
    other_groups = []

    # Put the reference first in its own data group
    for group in groups:
        if ref_id in group:
            group.remove(ref_id)
            group.insert(0, ref_id)
            ref_group = group
        else:
            other_groups.append(group)

    # First display energies table for the group with the refrence if it exists
    if ref_group is not None:
        render_energies_table(section, computed_data, ref_group)
        isContentAdded = True

    # Than display the other energies tables if they exists
    for group in other_groups:
        
        render_energies_table(section, computed_data, group)
        
        if (isContentAdded == False):
            isContentAdded = True
            
    return isContentAdded


def render_ref_MO_diagram(section, output_dir, computed_data: ComputedData, report_type):
    
    # figure with MO not available in text report type
    if report_type == 'text':
        return False
    
    ref_id = computed_data.metadata.ref_log_file_idx
    homo_ind = computed_data.results.wavefunction.homo_indexes[ref_id]
    MO_labels = computed_data.derived.wavefunction.MO_analysis.MO_labels[ref_id]
    
    # Skip if no data to display
    if (
        homo_ind == None
        or MO_labels == None
        or len(MO_labels[0]) == 0
    ):
        return False
    
    # For unrestricted calculation (alpha and beta spin electrons) display asked orbitals (one by each spin) and use two cameras for each
    if len(homo_ind) == 2:
        labels_alpha = MO_labels[0]
        labels_beta = MO_labels[1]
        
        for i in range(len(labels_alpha)):
            
            label_alpha = labels_alpha[i]
            label_beta = labels_beta[i]

            nomPng_alpha = f"img-log{ref_id}-MO-{label_alpha}.png"
            nomPng_beta  = f"img-log{ref_id}-MO-{label_beta}.png"

            path_alpha = os.path.join(output_dir, nomPng_alpha)
            path_beta = os.path.join(output_dir, nomPng_beta)

            base_label = label_alpha.replace("_alpha","")
            if os.path.isfile(path_alpha) and os.path.isfile(path_beta):
                caption = f"Representation of the MO {base_label.upper()} for spin α (left) and spin β (right)."
                figure_two_col(section, nomPng_alpha, nomPng_beta, caption=caption)
            elif os.path.isfile(path_alpha):
                caption = f"Representation of the MO {base_label.upper()} for spin α."
                figure_one_col(section, nomPng_alpha, caption=caption)
            elif os.path.isfile(path_beta):
                caption = f"Representation of the MO {base_label.upper()} for spin β."
                figure_one_col(section, nomPng_beta, caption=caption)
    
    # For restricted calculation display asked orbitals and use two cameras for each
    else:
        labels = MO_labels[0]
        for label in labels:
            nomPng = f"img-log{ref_id}-MO-{label}.png"
            nomPng2 = f"img-log{ref_id}-MO-{label}_cam2.png"
            
            path1 = os.path.join(output_dir, nomPng)
            path2 = os.path.join(output_dir, nomPng2)
            
            if os.path.isfile(path1) and os.path.isfile(path2):
                caption = f"Representation of the MO {label.upper()} from two points of view."
                figure_two_col(section, nomPng, nomPng2, caption=caption)
            elif os.path.isfile(path1):  # fallback si cam2 manquant
                caption = f"Representation of the MO {label.upper()}."
                figure_one_col(section, nomPng, caption=caption)
    
    return True


def render_ref_MEP_maps(section, output_dir, computed_data: ComputedData, report_type):
    # MEP map figures is only printed in full type report 
    if report_type != "full":
        return False
    
    ref_id = computed_data.metadata.ref_log_file_idx
    
    # figure with ESP
    nomPng = f"img-log{ref_id}-MEP_fixed.png"
    nomPng2 = f"img-log{ref_id}-MEP_fixed_cam2.png"                                                        
    if (os.path.isfile(output_dir + nomPng)) :
        if (os.path.isfile(output_dir + nomPng2)) :
            figure_two_col(section, nomPng, nomPng2, caption="Representations of the Molecular Electrostatic Potential mapped on the electron density (cutoff value of 0.002 e-/bohr3). On the left, red, blue and green regions correspond to negative values < -0.06 a.u., positive values > 0.08 a.u. and neutral values respectively. On the right, the scale is set automatically to highlight the minimum values in red and the maximum values in blues.")
            return True
        elif ( not os.path.isfile(output_dir + nomPng2)) :
            figure_one_col(section, nomPng, taillePng="10cm", 
            caption="Representations of the Molecular Electrostatic Potential mapped on the electron density (cutoff value of 0.002 e-/bohr3). On the left, red, blue and green regions correspond to negative values < -0.06 a.u., positive values > 0.08 a.u. and neutral values respectively.")
            return True

    return False


def render_ref_population_analysis(section, computed_data: ComputedData, report_type):
    # Only display when report type is full
    if report_type != "full":
        return False

    ref_id = computed_data.metadata.ref_log_file_idx
    log_file = computed_data.metadata.log_files[ref_id]
    atoms_Z = computed_data.molecule.atoms_Z[ref_id]
    mulliken = np.array(computed_data.results.wavefunction.Mulliken_partial_charges or [])
    hirshfeld = np.array(computed_data.results.wavefunction.Hirshfeld_partial_charges or [])
    cm5 = np.array(computed_data.results.wavefunction.CM5_partial_charges or [])
    derived = computed_data.derived.wavefunction.pop_analysis
    indices = computed_data.derived.wavefunction.pop_analysis.indices
    
    stats = {
        "Mulliken": 
            (derived.Mulliken_mean, derived.Mulliken_std) if derived.Mulliken_mean is not None and derived.Mulliken_std is not None else None,
        "Hirshfeld": 
            (derived.Hirshfeld_mean, derived.Hirshfeld_std) if derived.Hirshfeld_mean is not None and derived.Hirshfeld_std is not None else None,
        "CM5": 
            (derived.CM5_partial_mean, derived.CM5_partial_std) if derived.CM5_partial_mean is not None and derived.CM5_partial_std is not None else None,
    }

    # Skip if no data to display
    stats = {k: v for k, v in stats.items() if v is not None}
    if not stats:
        return False

    # Skip if no data to display
    if not indices:
        return False

    # Display mean and std for each method available
    with section.create(LongTable("p{0.6\\textwidth}p{0.2\\textwidth}p{0.2\\textwidth}")) as stats_table:
        stats_table.add_row(
            [MultiColumn(3, align='l', data=f"Population analysis: atomic charge statistics. (Source: {log_file})")])
        for method, (mean, std) in stats.items():
            stats_table.add_row([
                f"Mean {method} atomic charge and standard deviation",
                f"{mean:.4f} e-",
                f"{std:.4f} e-"
            ])

    # Display atoms with significant charges (exceeding ±1σ in at least one method)
    # Show all methods' charges per atom, bolding values exceeding their method-specific threshold
    n_cols = 1 + len(stats)
    col_format = ("p{0.15\\textwidth}") * n_cols
    with section.create(LongTable(col_format)) as pop_analysis_table:
        pop_analysis_table.add_row(
            [MultiColumn(n_cols, align='l', data="Table. Population analysis: atoms with significant charge deviations.")]
        )
        # Legend for values in bold if multipe methods displayed
        if len(stats) != 1:
            pop_analysis_table.add_row(
                [MultiColumn(n_cols, align='l', data="Values in bold lie outside the ±1 standard deviation range for their respective method.")]
            )
        pop_analysis_table.add_row(
            [MultiColumn(n_cols, align='l', data=f"Source: {log_file}")]
        )
        pop_analysis_table.add_hline()
        pop_analysis_table.add_row(["Atom (N°)"] + [f"{m} charge" for m in stats])
        pop_analysis_table.add_hline()

        for idx in indices:
            atom_label = f"{PeriodicTable().element[atoms_Z[idx]]} (N°{idx+1})"
            row = [atom_label]

            for method in stats:
                charges = {
                    "Mulliken": mulliken,
                    "Hirshfeld": hirshfeld,
                    "CM5": cm5
                }[method]

                val = charges[idx]
                mean, std = stats[method]
                
                # If multiple methods displayed, draw in bold value outisde of the range
                if (
                    len(stats) != 1
                    and 
                    (
                        val < mean - std
                        or val > mean + std
                    )
                ):
                    val_str = NoEscape(r'\textbf{' + f"{val:+.3f}" + r'}')
                else:
                    val_str = f"{val:+.3f}"

                row.append(val_str)

            pop_analysis_table.add_row(row)
        pop_analysis_table.add_hline()
        
    return True


def fill_wavefunction_section(doc, output_dir, computed_data: ComputedData, report_type, config_output: OutputInclude):
    
    section = Section('WAVEFUNCTION')
    
    added_energies = False
    added_ref_MO_diagram = False
    added_ref_MEP_maps = False
    added_ref_population_analysis = False
    
    # Render energies tables for each log file when available (reference first)
    if config_output.wavefunction.MO_analysis.energies:
        added_energies = render_energies(section, computed_data)
    
    # Render the MO_diagram of the reference data
    if config_output.wavefunction.MO_analysis.MO_diagrams:
        added_ref_MO_diagram = render_ref_MO_diagram(section, output_dir, computed_data, report_type)

    # Render the MEP_maps of the reference data
    if config_output.wavefunction.MEP_maps :
        added_ref_MEP_maps = render_ref_MEP_maps(section, output_dir, computed_data, report_type)
    
    # Render population population analysis on the reference
    if config_output.wavefunction.population_analysis :
        added_ref_population_analysis = render_ref_population_analysis(section, computed_data, report_type)
    
    if (
        added_energies
        or added_ref_MO_diagram
        or added_ref_MEP_maps
        or added_ref_population_analysis
    ):
        doc.append(section)


def render_thermo_data(section, computed_data: ComputedData):
    
    ref_id = computed_data.metadata.ref_log_file_idx
    log_files = computed_data.metadata.log_files
    all_temperatures = computed_data.comp_details.freq.temperature
    all_vibrational_int = computed_data.results.freq.vibrational_int
    all_zero_point_energy = computed_data.results.freq.zero_point_energy
    all_electronic_thermal_energy = computed_data.results.freq.electronic_thermal_energy
    all_enthalpy = computed_data.results.freq.enthalpy
    all_free_energy = computed_data.results.freq.free_energy
    all_entropy = computed_data.results.freq.entropy
    
    isContentAdded = False
    
    # Display reference first if available
    indices = list(range( len(log_files) ))
    if ref_id in indices:
        indices.remove(ref_id)
        indices.insert(0, ref_id)
    
    # Display thermo data for each logfile when available
    for i in indices:
        
        if all_temperatures[i] != None:
            rtemper = all_temperatures[i]
        else:
            rtemper = []
            
        if all_vibrational_int[i] != None:
            vibrational_int = np.array(all_vibrational_int[i])
        else:
            vibrational_int = []
        
        # TODO : TO CHECK : Unused nb_negatives value
        # if len(vibrational_int) == 0 :
        #     vibrational_int = []
        # else :  
        #     # Print number of negative frequencies   
        #     nb_negatives = np.sum(vibrational_freq < 0, axis=0)
        
        log_file = log_files[i]
        zero_point_energy = all_zero_point_energy[i]
        electronic_thermal_energy = all_electronic_thermal_energy[i]
        enthalpy = all_enthalpy[i]
        free_energy = all_free_energy[i]
        entropy = all_entropy[i]
        
        # Skip if no data to display
        if (
            zero_point_energy == None
            and electronic_thermal_energy == None
            and enthalpy == None
            and free_energy == None
            and entropy == None
        ):
            continue
        
        if (isContentAdded == False):
            isContentAdded = True
        
        with section.create(LongTable("p{0.6\\textwidth} p{0.2\\textwidth} p{0.2\\textwidth}")) as thermo_data_table :
            thermo_data_table.add_row(["Frequency and Thermochemistry specific results", " " , " "])
            thermo_data_table.add_row([f"Source: {log_file}", " ", " "])
            
            if (len(vibrational_int) != 0) and (rtemper != "N/A") :
                if zero_point_energy != None:
                    thermo_data_table.add_row(['Sum of electronic and zero-point energy', 
                                        "%.5f Hartrees" % zero_point_energy, " "])
                if electronic_thermal_energy != None:
                    thermo_data_table.add_row(["Sum of electronic and thermal energies at  %.2f K"  % rtemper, 
                                        "%.5f Hartrees" % electronic_thermal_energy, " "])
                if enthalpy != None:
                    thermo_data_table.add_row(["Enthalpy at %.2f K" % rtemper,
                                        "%.5f Hartrees" % enthalpy, " "])
                if free_energy != None :
                    thermo_data_table.add_row(["Gibbs free energy at %.2f K" % rtemper,
                                        "%.5f Hartrees" % free_energy, " "])
                if entropy != None :
                    thermo_data_table.add_row(["Entropy at %.2f K" % rtemper, 
                                        "%.5f Hartrees" % entropy, " "])
                thermo_data_table.add_row([" ", " " , " "])
    
    return isContentAdded


def render_IR_spectrum(section, computed_data: ComputedData):
    
    ref_id = computed_data.metadata.ref_log_file_idx
    log_files = computed_data.metadata.log_files
    all_vibrational_int = computed_data.results.freq.vibrational_int
    all_vibrational_freq = computed_data.results.freq.vibrational_freq
    all_vibrational_sym = computed_data.results.freq.vibrational_sym
    
    isContentAdded = False
    
    # Display reference first if available
    indices = list(range( len(log_files) ))
    if ref_id in indices:
        indices.remove(ref_id)
        indices.insert(0, ref_id)
    
    # Display thermo data for each logfile when available
    for i in indices:
        
        if all_vibrational_int[i] != None:
            vibrational_int = np.array(all_vibrational_int[i])
        else:
            vibrational_int = []
            
        if all_vibrational_freq[i] != None:
            vibrational_freq = np.array(all_vibrational_freq[i])
        else:
            vibrational_freq = []   
            
        if all_vibrational_sym[i] != None:
            vibrational_sym = np.array(all_vibrational_sym[i])
        else:
            vibrational_sym = np.array(["N/A" for _ in range(len(vibrational_int))])
            
        log_file = log_files[i]
        k = 0
        
        # filtering & orderering
        if len(vibrational_int) == 0 :
            vibrational_int = []
        else :  
            vib_filter = vibrational_int > THRESHOLD_IR_INTENSITIES
            vib_order = np.argsort(vibrational_freq[vib_filter])[::-1]
            vibrational_int = vibrational_int[vib_filter][vib_order]
            vibrational_freq = vibrational_freq[vib_filter][vib_order]
            vibrational_sym = vibrational_sym[vib_filter][vib_order]
            
        # Skip if no data to display
        if (
            len(vibrational_freq) == 0 or
            len(vibrational_int) == 0 or
            len(vibrational_sym) != len(vibrational_freq)
        ):
            continue
        
        if (isContentAdded == False):
            isContentAdded = True
            
        section.append(NoEscape(r'\begin{center}'))
        with section.create(Tabular('rrrc')) as ir_spectrum_table :
            row_cells = [MultiColumn(4, align='c', 
                                        data="Table. Most intense (> 50 km/mol) molecular vibrations in wavenumbers")]
            ir_spectrum_table.add_row(row_cells)
            ir_spectrum_table.add_row(
                [MultiColumn(4, align='l', 
                data=f"Source: {log_file}")]
            )
            ir_spectrum_table.add_hline()
            ir_spectrum_table.add_row(["", "Frequencies", "Intensity", "Symmetry"])
            ir_spectrum_table.add_hline()
            for k in range(len(vibrational_freq)) :
                ir_spectrum_table.add_row(["",
                                "%d" % vibrational_freq[k],
                                "%d" % vibrational_int[k], 
                                vibrational_sym[k]])
            ir_spectrum_table.add_hline()
        section.append(NoEscape(r'\end{center}'))
    
    return isContentAdded


def fill_frequencies_section(doc, computed_data: ComputedData, config_output: OutputInclude):
    
    section = Section('FREQUENCIES')
    
    added_thermo_data = False
    added_IR_spectrum = False
        
    # Render thermo data for each log file when available (reference first)
    if config_output.frequencies.thermo_data:
        added_thermo_data = render_thermo_data(section, computed_data)
    
    # Render IR spectrum for each log file when available (reference first)
    if config_output.frequencies.IR_spectrum:
        added_IR_spectrum = render_IR_spectrum(section, computed_data)

    if (
        added_thermo_data
        or added_IR_spectrum
    ):
        doc.append(section)

def render_CDFT_global_indices(section, computed_data: ComputedData, report_type):
    # CDFT Indices table only in full report
    if report_type != 'full': 
        return False
    
    A = computed_data.results.wavefunction.A
    I = computed_data.results.wavefunction.I
    Khi = computed_data.results.wavefunction.Khi
    Eta = computed_data.results.wavefunction.Eta
    Omega = computed_data.results.wavefunction.Omega
    DeltaN = computed_data.results.wavefunction.DeltaN
    
    # Skip if no data to display
    if (
        A == None
        and I == None
        and Khi == None
        and Eta == None
        and Omega == None
        and DeltaN == None
    ):
        return False
    
    with section.create(LongTable("p{0.6\\textwidth} p{0.2\\textwidth} p{0.2\\textwidth}")) as CDFT_indicies_table :
        CDFT_indicies_table.add_row([" ", " " , " "])
        if A != None:
            CDFT_indicies_table.add_row(['CDFT indices: Electron Affinity', "%.4f hartrees" % A , ""  ] )
            
        if I != None:
            CDFT_indicies_table.add_row(['CDFT indices: Ionisation Potential', "%.4f hartrees" % I , ""  ] )
        
        if Khi != None:
            CDFT_indicies_table.add_row(['CDFT indices: Electronegativity', "%.4f hartrees" % Khi , ""  ] )
        
        if Eta != None:
            CDFT_indicies_table.add_row(['CDFT indices: Hardness', "%.4f hartrees" % Eta , ""  ] )
    
        if Omega != None:
            CDFT_indicies_table.add_row(['CDFT indices: Electrophilicity', "%.4f " % Omega , ""  ] )
        
        if DeltaN != None:
            CDFT_indicies_table.add_row(['CDFT indices: Electron-flow', "%.4f e-" % DeltaN, ""  ] )
    
    return True


def render_fukui_table(doc, atoms_Z, fplus, fminus, fdual, title):
    has_data = len(fplus) > 0 or len(fminus) > 0
    if not has_data:
        return

    n_atoms = len(atoms_Z)
    has_dual = len(fdual) > 0
    ind = list(range(n_atoms))

    if has_dual:
        fdual = np.array(fdual)
        mean_fd = np.mean(fdual)
        dev_fd = np.std(fdual)
        thres_max = mean_fd + dev_fd
        thres_min = mean_fd - dev_fd
        ind = np.argsort(fdual)

    doc.append(NoEscape(r'\begin{center}'))
    with doc.create(Tabular('p{0cm}rrrrp{0cm}')) as fukui_table:
        row_cells = [MultiColumn(6, align='c', data=f"Table. Condensed Fukui functions based on {title} charges.")]
        fukui_table.add_row(row_cells)
        fukui_table.add_hline()
        fukui_table.add_row(["", "Atom", "atomic dual descriptor (f+ - f-)", "atomic electrophilicity f+", "atomic nucleophilicity f-", ""])
        fukui_table.add_hline()

        for i in ind:
            fplus_val = fplus[i] if i < len(fplus) else None
            fminus_val = fminus[i] if i < len(fminus) else None
            fdual_val = fdual[i] if has_dual and i < len(fdual) else None
            
            # Skip unwanted values
            if has_dual:
                if fdual_val is None or (thres_min <= fdual_val <= thres_max):
                    continue
            else:
                if fplus_val is None and fminus_val is None:
                    continue

            atom_label = "%s %d" % (PeriodicTable().element[atoms_Z[i]], i + 1)
            fukui_table.add_row([
                "",
                atom_label,
                "  %.2f" % fdual_val if fdual_val is not None else "",
                "  %.2f" % fplus_val if fplus_val is not None else "",
                "  %.2f" % fminus_val if fminus_val is not None else "",
                ""
            ])

        fukui_table.add_hline()
    doc.append(NoEscape(r'\end{center}'))


def render_condensed_fukui_functions(section, computed_data: ComputedData):

    def safe(val): return val if val is not None else [] 
    
    ref_id = computed_data.metadata.ref_log_file_idx
    atoms_Z = computed_data.molecule.atoms_Z[ref_id]

    fplus_lambda_hirshfeld = safe(computed_data.results.wavefunction.fplus_lambda_hirshfeld)
    fminus_lambda_hirshfeld = safe(computed_data.results.wavefunction.fminus_lambda_hirshfeld)
    fdual_lambda_hirshfeld = safe(computed_data.results.wavefunction.fdual_lambda_hirshfeld)

    fplus_lambda_mulliken = safe(computed_data.results.wavefunction.fplus_lambda_mulliken)
    fminus_lambda_mulliken = safe(computed_data.results.wavefunction.fminus_lambda_mulliken)
    fdual_lambda_mulliken = safe(computed_data.results.wavefunction.fdual_lambda_mulliken)
    
    # Skip if no data
    if (
        len(fplus_lambda_hirshfeld) == 0
        and len(fminus_lambda_hirshfeld) == 0
        and len(fplus_lambda_mulliken) == 0
        and len(fminus_lambda_mulliken) == 0
    ):
        return False

    render_fukui_table(
        section,
        atoms_Z,
        fplus_lambda_hirshfeld,
        fminus_lambda_hirshfeld,
        fdual_lambda_hirshfeld,
        "Hirshfeld"
    )
    
    render_fukui_table(
        section,
        atoms_Z,
        fplus_lambda_mulliken,
        fminus_lambda_mulliken,
        fdual_lambda_mulliken,
        "Mulliken"
    )
    
    return True


def render_fukui_functions(section, output_dir, computed_data: ComputedData, report_type):
    # Figures of that are only printed in full type report 
    if report_type != 'full':
        return False
    
    isContentAdded = False
        
    # figures of Fukui functions if calculated
    nomPng = "img-fukui-SP_plus.png"
    nomPng2 = "img-fukui-SP_plus_cam2.png"                                                        
    nomPng3 = "img-fukui-SP_minus.png"
    nomPng4 = "img-fukui-SP_minus_cam2.png"                                                        
    if (os.path.isfile(output_dir + nomPng)) :
        if (os.path.isfile(output_dir + nomPng2)) :
            figure_two_col(section, nomPng, nomPng2, caption="Representation of the F+ function from two points of view. The Blue color indicate the most electrophilic regions.")
            if (os.path.isfile(output_dir + nomPng3)) :
                if (os.path.isfile(output_dir + nomPng4)) :
                    figure_two_col(section, nomPng3, nomPng4, caption="Representation of the F- function from two points of view. The Blue color indicate the most nucleophilic regions.")
            isContentAdded = True
        elif (os.path.isfile(output_dir + nomPng3)) :
            figure_two_col(section, nomPng, nomPng3, caption="Representation of the electrophilic (left) and nucleophilic (right) fukui functions.")
            isContentAdded = True
    
    nomPng = "img-Fdual.png"
    nomPng2 = "img-Fdual_cam2.png"                                                        
    if (os.path.isfile(output_dir + nomPng)) :
        if (os.path.isfile(output_dir + nomPng2)) :
            figure_two_col(section, nomPng, nomPng2, caption="Representation of the Dual descriptor from two points of view. Electrophilic and nucleophilic regions correspond to blue and white surfaces.")
        else :
            figure_one_col(section, nomPng, caption="Representation of the Dual descriptor from one point of view. Electrophilic and nucleophilic regions correspond to blue and white surfaces.")
        isContentAdded = True
    
    return isContentAdded


def fill_reactivity_section(doc, output_dir, computed_data: ComputedData, report_type, config_output: OutputInclude):
    
    section = Section('REACTIVITY')
    
    added_CDFT_global_indices = False
    added_condensed_fukui_functions = False
    added_fukui_functions = False
    
    # Render CDFT global indicies
    if config_output.reactivity.CDFT_indices:
        added_CDFT_global_indices = render_CDFT_global_indices(section, computed_data, report_type)
    
    if config_output.reactivity.fukui_functions:
        # Render condensed fukui functions
        added_condensed_fukui_functions = render_condensed_fukui_functions(section, computed_data)
    
        # Render fukui functions
        added_fukui_functions = render_fukui_functions(section, output_dir, computed_data, report_type)
    
    if (
        added_CDFT_global_indices
        or added_condensed_fukui_functions
        or added_fukui_functions
    ):
        doc.append(section)


def select_excited_states_indices(computed_data: ComputedData, log_idx, selection_mode="dominant_only", n=5, osc_threshold=0.1, rot_threshold=10):
    """
    Select excited states indices based on the selection mode.
    
    - "dominant_only" : only select states with significant oscillator strength (osc > osc_threshold) or rotation (R > rot_threshold)
    - "first_n" : take the first n states
    - "all_states" : take all available excited states
    """
    
    et_energies = computed_data.results.excited_states.et_energies[log_idx]
    oscs = computed_data.results.excited_states.et_oscs[log_idx]
    rots = computed_data.results.excited_states.et_rot[log_idx]
    
    if (
        et_energies == None
        or (
            selection_mode == "dominant_only"
            and (
                oscs == None
                or rots == None
            )
        )
    ): 
        return []
    
    n_states = len(et_energies)

    if selection_mode == "all_states":
        return list(range(n_states))
    
    elif selection_mode == "first_n":
        return list(range(min(n, n_states)))

    elif selection_mode == "dominant_only":
        selected = []

        for i in range(n_states):
            if i < 5:
                selected.append(i)
                continue

            osc_i = oscs[i]
            if osc_i is not None and osc_i > osc_threshold:
                selected.append(i)
                continue

            rot_i = rots[i]
            if rot_i == "N/A":
                selected.append(i)
                continue
            try:
                if abs(float(rot_i)) > rot_threshold:
                    selected.append(i)
            except (ValueError, TypeError):
                pass

        return sorted(set(selected))
    
    else:
        raise ValueError(f"Unknown selection_mode: {selection_mode}")

def build_CIS_string(transitions, homo_ind, filter_threshold=5):
    CIS = ""
    for ST in transitions:
        coeff = int(ST[2] ** 2 * 100)
        if coeff >= filter_threshold:
            mo_i, spin_i = ST[0]
            mo_f, spin_f = ST[1]
            if len(homo_ind) == 2:  # Unrestricted
                spin_map = {0: "a", 1: "b"}
                spin_i_str = spin_map.get(spin_i, "")
                spin_f_str = spin_map.get(spin_f, "")
                CIS += f"{mo_i+1}{spin_i_str}-{mo_f+1}{spin_f_str} ({coeff}) "
            else:  # Restricted
                CIS += f"{mo_i+1}->{mo_f+1} ({coeff}) "
    return CIS.strip()


def render_excited_state_transitions_table(doc, computed_data: ComputedData, log_idx, is_optimized=False, indices=None, report_type="full", title=""):

    log_files = computed_data.metadata.log_files[log_idx]
    homo_ind = computed_data.results.wavefunction.homo_indexes[log_idx]
    et_energies = computed_data.results.excited_states.et_energies[log_idx]
    et_oscs = computed_data.results.excited_states.et_oscs[log_idx]
    et_rot = computed_data.results.excited_states.et_rot[log_idx]
    et_transitions = computed_data.results.excited_states.et_transitions[log_idx]
    et_sym = computed_data.results.excited_states.et_sym[log_idx]

    # Skip is data is missing for excited state
    if (
        homo_ind == None
        or et_energies == None
        or et_oscs == None
        or et_rot == None
        or et_transitions == None
        or et_sym == None
    ):
        return False
    
    if is_optimized:
        Tozer_lambda = computed_data.derived.optimized_excited_states.Tozer_lambda[log_idx]
        d_ct = computed_data.derived.optimized_excited_states.d_ct[log_idx]
        q_ct = computed_data.derived.optimized_excited_states.q_ct[log_idx]
    else:
        Tozer_lambda = computed_data.derived.excited_states.Tozer_lambda[log_idx]
        d_ct = computed_data.derived.excited_states.d_ct[log_idx]
        q_ct = computed_data.derived.excited_states.q_ct[log_idx]
    
    use_full = (report_type != 'text')

    # Skip is data is missing for optimized excited state
    if (
        use_full
        and
        (
            Tozer_lambda == None
            or d_ct == None
            or q_ct == None
        )
    ):
        return False
    
    if is_optimized:
        title = "Table. Results concerning the calculated mono-electronic optimization excitation."
    else:
        title = "Table. Results concerning the calculated mono-electronic excitations."

    et_nm = [nm_to_wnb / e if e else 0 for e in et_energies]

    doc.append(NoEscape(r'\begin{center}'))
    
    ncols = 10 if use_full else 7

    table_format = 'r' * (ncols - 1) + 'p{6cm}'
    with doc.create(Tabular(table_format)) as es_transitions_table:
        es_transitions_table.add_row([MultiColumn(ncols, align='c', data=title)])
        es_transitions_table.add_row([MultiColumn(ncols, align='c', data=f"Source: {log_files}")])
        es_transitions_table.add_hline()
        if use_full:
            es_transitions_table.add_row(["E.S.", "Symmetry", "nm", NoEscape(r"cm$^{-1}$"),
                            italic("f"), "R", NoEscape(r"$\Lambda$"),
                            NoEscape(r"d$_{CT}$"), NoEscape(r"q$_{CT}$"),
                            "Excitation description in %"])
        else:
            es_transitions_table.add_row(["E.S.", "Symmetry", "nm", NoEscape(r"cm$^{-1}$"),
                            italic("f"), "R", "Excitation description in %"])
        es_transitions_table.add_hline()

        if indices is None:
            indices = range(len(et_transitions))

        for idx in indices:
            
            energy = et_energies[idx] if et_energies[idx] is not None else 0.0
            nm_val = et_nm[idx] if et_nm[idx] is not None else 0
            osc = et_oscs[idx]
            rot = et_rot[idx]
            rot_val = rot if rot is not None else "N/A"

            if use_full:
                lambda_val = Tozer_lambda[idx]
                d_ct_val = d_ct[idx]
                q_ct_val = q_ct[idx]
            
            # Skip if no data computed
            # Only print the visualization of the user-selected excited transition
            if (
                lambda_val is None
                or d_ct_val is None
                or q_ct_val is None
            ):
                continue

            trans = et_transitions[idx]
            CIS = build_CIS_string(trans, homo_ind, filter_threshold=0 if is_optimized else 5)

            row = [
                (idx + 1),
                et_sym[idx],
                f"{int(nm_val)}",
                f"{int(energy)}",
                f"{osc:.3f}",
                f"{rot_val}"
            ]

            if use_full:
                row += [
                    f"{lambda_val:.2f}",
                    f"{d_ct_val:.2f}",
                    f"{q_ct_val:.2f}",
                ]

            row.append(CIS)
            es_transitions_table.add_row(row)

        es_transitions_table.add_hline()

    doc.append(NoEscape(r'\end{center}'))
    
    return True


def render_es_transitions(section, computed_data: ComputedData, report_type):

    log_files = computed_data.metadata.log_files
    job_types = computed_data.comp_details.general.job_type
    isContentAdded = False
    
    for i, _ in enumerate(log_files):
        if job_types[i] == None or  "td" not in job_types[i]:
            continue
        
        content_added = render_excited_state_transitions_table(
            section,
            computed_data,
            log_idx=i,
            report_type=report_type
        )
        
        if (
            isContentAdded == False 
            and content_added
        ):
            isContentAdded = True
            
    return isContentAdded


def render_es_absorption_and_CD_spectrum(section, output_dir, computed_data: ComputedData, report_type):
    
    log_files = computed_data.metadata.log_files
    job_types = computed_data.comp_details.general.job_type
    isContentAdded = False
    
    for log_idx, log_file in enumerate(log_files):
    
        jobs = job_types[log_idx]
        
        if (
            "td" not in jobs
        ):
            continue
        
        content_added = False
            
        # UV visible Absorption plots
        imgNameAbso = f"img-log{log_idx+1}-UV-Abso-Spectrum.png"
        if (os.path.isfile(output_dir + imgNameAbso)) :
            figure_one_col(section, imgNameAbso, taillePng="10cm", 
                caption=f"Calculated UV visible Absorption spectrum with a gaussian broadening (FWHM = 3000 cm-1). (Source: {log_file})"
            )
            content_added = True
            
        
        # Circular dischroism plots
        imgNameCD= f"img-log{log_idx+1}-UV-CD-Spectrum.png"
        if (os.path.isfile(output_dir + imgNameCD)) :
            figure_one_col(section, imgNameCD, taillePng="10cm", 
                caption=f"Calculated Circular Dichroism spectrum with a gaussian broadening (FWHM = 3000 cm-1. (Source: {log_file})"
            )
            content_added = True
            
        if (
            isContentAdded == False
            and content_added
        ):
            isContentAdded = True
            
    return isContentAdded


def render_es_EDD(section, output_dir, computed_data: ComputedData, report_type):
    # figures not available in text report type
    if report_type == 'text':
        return False

    log_files = computed_data.metadata.log_files
    job_types = computed_data.comp_details.general.job_type

    isContentAdded = False
    
    for log_idx, log_file in enumerate(log_files):
        
        et_transitions = computed_data.results.excited_states.et_transitions[log_idx]
        jobs = job_types[log_idx]
        
        if (
            "td" not in jobs
            or et_transitions is None
        ):
            continue
        
        for k in range(len(et_transitions)):
            nomPng = f"img-log{log_idx+1}-EDD-S{k+1}.png"
            nomPng_cam2 = f"img-log{log_idx+1}-EDD-S{k+1}_cam2.png"  
            
            if (os.path.isfile(output_dir + nomPng)) :
                if (os.path.isfile(output_dir + nomPng_cam2)) :
                    figure_two_col(section, nomPng, nomPng_cam2, caption=f"Representation of the Electron Density Difference (S{k+1}) from two points of view. (Source: {log_file})")
                else:
                    figure_one_col(section, nomPng, caption=f"Representation of the Electron Density Difference (S{k+1}). (Source: {log_file})")
                
                if (isContentAdded == False):
                    isContentAdded = True
                
        # TODO : TO CHECK : These images seem to never be generated
        # nomPng = "img-EDD-1.png"
        # nomPng_cam2 = "img-EDD-1_cam2.png"
        # nomPng2 = "img-EDD-2.png"
        # nomPng2_cam2 = "img-EDD-2_cam2.png"
        # if (os.path.isfile(output_dir + nomPng)) :
        #     if (os.path.isfile(output_dir + nomPng_cam2)) :
        #         figure_two_col(doc, nomPng, nomPng_cam2, caption="Representation of the Electron Density Difference (ES1-GS) from two points of view.")
        #         if (os.path.isfile(output_dir + nomPng2)) :
        #             if (os.path.isfile(output_dir + nomPng2_cam2)) :
        #                 figure_two_col(doc, nomPng2, nomPng2_cam2, caption="Representation of the Electron Density Difference (ES2-GS) from two points of view.")
        #     elif (os.path.isfile(output_dir + nomPng2)) :
        #         figure_two_col(doc, nomPng, nomPng2, caption="Representation of the Electron Density Difference (ES1-GS left) and (ES2-GS right). The excited electron and the hole regions are indicated by respectively blue and white surfaces.")

    return isContentAdded


def fill_excited_states_section(doc, output_dir, computed_data: ComputedData, report_type, config_output: OutputInclude):
    section = Section('EXCITED STATES')

    added_es_transition = False
    added_es_abso_and_cd = False
    added_es_EDD = False
    
    # Render excited states transition for each available TD logfile
    if config_output.excited_states.transitions:
        added_es_transition = render_es_transitions(section, computed_data, report_type)
    
    # Render excited states Absorption and CD Spectrum for each available TD logfile
    if (
        config_output.excited_states.absorption_spectrum
        or config_output.excited_states.CD_spectrum
    ):
        added_es_abso_and_cd = render_es_absorption_and_CD_spectrum(section, output_dir, computed_data, report_type)
    
    # Render excited states EDD for each available TD logfile
    if config_output.excited_states.electron_density_difference:
        added_es_EDD = render_es_EDD(section, output_dir, computed_data, report_type)
    
    if (
        added_es_transition
        or added_es_abso_and_cd
        or added_es_EDD
    ):
        doc.append(section)


def render_optimized_es_transitions(section, computed_data: ComputedData, report_type, config: Config):
    log_files = computed_data.metadata.log_files
    job_types = computed_data.comp_details.general.job_type

    isContentAdded = False

    for i, _ in enumerate(log_files):
        if job_types[i] == None or "opt_es" not in job_types[i]:
            continue

        emi_state = config.logfiles[i].excited_state_number
        indices = emi_state - 1
        
        content_added = render_excited_state_transitions_table(
            section,
            computed_data,
            log_idx=i,
            indices=[indices],
            is_optimized=True,
            report_type=report_type
        )
        
        if (
            isContentAdded == False
            and content_added
        ):
            isContentAdded = True
            
    return isContentAdded


def render_optimized_es_emission_spectrum(section, output_dir, computed_data: ComputedData, report_type):
    
    log_files = computed_data.metadata.log_files
    job_types = computed_data.comp_details.general.job_type
    
    isContentAdded = False
    
    for log_idx,_ in enumerate(log_files):
        
        jobs = job_types[log_idx]
        
        if not any("_es" in jb for jb in jobs):
            continue
        
        # UV visible Emission plots
        imgNamePng = f"img-log{log_idx}-UV-Emi-Spectrum.png"
        if (not os.path.isfile(output_dir + imgNamePng)) :
            continue
        
        figure_one_col(section, imgNamePng, taillePng="10cm", 
            caption="Calculated UV visible Emission spectrum with a gaussian broadening (FWHM = 3000 cm-1)"
        )
        
        if (isContentAdded == False):
            isContentAdded = True
    
    return isContentAdded


def render_optimized_es_CPL_spectrum(section, output_dir, computed_data: ComputedData, report_type):
    
    log_files = computed_data.metadata.log_files
    job_types = computed_data.comp_details.general.job_type
    
    isContentAdded = False
    
    for log_idx,_ in enumerate(log_files):
        
        jobs = job_types[log_idx]
        
        if not any("_es" in jb for jb in jobs):
            continue
    
        imgNamePng = f"img-log{log_idx}-UV-CD-Emi-Spectrum.png"
        if (not os.path.isfile(output_dir + imgNamePng)) :
            continue
        
        figure_one_col(section, imgNamePng, taillePng="10cm", 
            caption="Calculated Circular Dichroism Emission spectrum with a gaussian broadening (FWHM = 3000 cm-1)"
        )
        
        if (isContentAdded == False):
            isContentAdded = True
    
    return isContentAdded


def render_optimized_es_EDD(section, output_dir, computed_data: ComputedData, config: Config, report_type):
    if report_type == 'text':
        return False
    
    log_files = computed_data.metadata.log_files
    job_types = computed_data.comp_details.general.job_type
    
    isContentAdded = False
    
    for log_idx,log_file in enumerate(log_files):
        
        jobs = job_types[log_idx]
        
        if not any("_es" in jb for jb in jobs):
            continue
        
        emi_state = config.logfiles[log_idx].excited_state_number
        
        # figure with EDD for emission
        imgNamePng = f"img-log{log_idx}-emi-EDD-S{emi_state}.png" 
        imgNamePng2 = f"img-log{log_idx}-emi-EDD-S{emi_state}_cam2.png" 
        if (not os.path.isfile(output_dir + imgNamePng)) :
            continue
        
        if (os.path.isfile(output_dir + imgNamePng2)):
            figure_two_col(section, imgNamePng, imgNamePng2, 
                caption=f"Representation of the Electron Density Difference (S{emi_state}) after optimization of the excited state from two points of view. "
                            + "The excited electron and the hole regions are indicated by respectively white and blue surfaces to ease "
                            + f"comparison with the corresponding absorption transition. (Source: {log_file})"
            )
        else:
            figure_one_col(section, imgNamePng, taillePng="10cm", 
                caption=f"Representation of the Electron Density Difference (S{emi_state}) after optimization of the excited state. "
                            + "The excited electron and the hole regions are indicated by respectively white and blue surfaces to ease "
                            + f"comparison with the corresponding absorption transition. (Source: {log_file})"
            )
        
        if (isContentAdded == False):
            isContentAdded = True
    
    return isContentAdded    


def fill_optimized_excited_states_section(doc, output_dir, computed_data: ComputedData, report_type, config: Config, config_output: OutputInclude):
    
    section = Section('OPTIMIZED EXCITED STATES')
    
    added_optimized_es_transitions = False
    added_optimized_es_emission_spectrum = False
    added_optimized_es_CPL_spectrum = False
    added_optimized_es_EDD = False
    
    # Render optimized excited states transition for each available TD logfile
    if config_output.optimized_excited_states.transitions:
        added_optimized_es_transitions = render_optimized_es_transitions(section, computed_data, report_type, config)
        
    # Render optimized excited states Emission Spectrum for each available TD logfile
    if config_output.optimized_excited_states.emission_spectrum:
        added_optimized_es_emission_spectrum = render_optimized_es_emission_spectrum(section, output_dir, computed_data, report_type)
        
    # Render optimized excited states CPL Spectrum for each available TD logfile
    if config_output.optimized_excited_states.CPL_spectrum:
        added_optimized_es_CPL_spectrum = render_optimized_es_CPL_spectrum(section, output_dir, computed_data, report_type)
        
    # Render optimized excited states EDD for each available TD logfile
    if config_output.optimized_excited_states.electron_density_difference:
        added_optimized_es_EDD = render_optimized_es_EDD(section, output_dir, computed_data, config, report_type)
    
    if (
        added_optimized_es_transitions
        or added_optimized_es_emission_spectrum
        or added_optimized_es_CPL_spectrum
        or added_optimized_es_EDD
    ):
        doc.append(section)


def fill_additional_molecule_representations_section(doc, computed_data: ComputedData):
    ref_id = computed_data.metadata.ref_log_file_idx
    output_dir = computed_data.metadata.output_dir
    log_files = computed_data.metadata.log_files
    topology_groups = computed_data.derived.molecule.topology_groups
    
    if topology_groups is None:
        return
    
    # Skip if no other molecule representations than the reference
    if all((group is None or ref_id in group) for group in topology_groups):
        return
    
    with doc.create(Section('ADDITIONAL MOLECULE REPRESENTATION')):
    
        for i,_ in enumerate(log_files):
            group = topology_groups[i]
            
            # Skip if no data
            if group is None:
                continue
            
            log_idx = group[0]
            
            # Skip the molecule representation of the reference since it's done in the molecule section
            if (log_idx == ref_id):
                continue
            
            nomPng = f"img-log{log_idx+1}-TOPOLOGY.png"
            
            if ( not os.path.isfile(output_dir + nomPng) ):
                print(f"{nomPng} not found. Molecule representation for the reference can not be added to the report.\n")
                return
            
            sources = ', '.join([log_files[i] for i in group])
            figure_one_col(doc, nomPng, caption=f"Chemical structure diagram with atomic numbering. (Source: {sources})")


def render_atomic_coordinates(doc, computed_data: ComputedData):
    ref_id = computed_data.metadata.ref_log_file_idx
    
    for i in range(len(computed_data.results.geometry.elements_3D_coords)):
        log_file = computed_data.metadata.log_files[i]
        atoms = computed_data.results.geometry.elements_3D_coords[i]
        atoms_Z = computed_data.molecule.atoms_Z[i]

        # Skip if the atomic_coodinates for the reference was displayed above
        if i == ref_id:
            if atoms is not None and len(atoms) < MAX_NUMBER_OF_ATOMS_TO_DISPLAY_ATOMIC_COORDINATE_REF_ABOVE:
                continue

        # Skip if no data for this instance
        if (
            atoms is None
            or atoms_Z is None
        ):
            continue

        atoms = np.array(atoms).reshape((-1, 3))

        render_atomic_coordinates_table(
            doc=doc,
            atoms=atoms,
            atoms_Z=atoms_Z,
            log_file=log_file,
            table_title='Table. Converged cartesian atomic coordinates in Angstroms',
        )


def fill_atomic_coordinates_section(doc, computed_data: ComputedData):
    ref_id = computed_data.metadata.ref_log_file_idx
    all_atoms = computed_data.results.geometry.elements_3D_coords
    all_atoms_Z = computed_data.molecule.atoms_Z

    # Check if all elements in all_atoms are None
    all_atoms_none = all(atom is None for atom in all_atoms)
    all_atoms_Z_none = all(atom_Z is None for atom_Z in all_atoms_Z)

    # Check if the only non-None element is the ref_id and it was displayed above
    only_ref_present = (
        sum(atom is not None for atom in all_atoms) == 1 and
        all_atoms[ref_id] is not None and
        len(all_atoms[ref_id]) < MAX_NUMBER_OF_ATOMS_TO_DISPLAY_ATOMIC_COORDINATE_REF_ABOVE
    )

    # If no data, or only ref data that is shown elsewhere, skip this section
    if all_atoms_none or all_atoms_Z_none or only_ref_present:
        return

    with doc.create(Section('ATOMIC COORDINATES')):
        # Render the table of atomic coordinates for each logfile if data is available
        render_atomic_coordinates(doc, computed_data)


def render_report_document(reportFile, output_dir, doc, mode):
    #####################################################################
    #                                                                   #
    ## 3. compilation LaTeX                                             #
    #                                                                   #
    #####################################################################
    
    # on compile
    # on previent si le fichier PDF est present ou pas
    # par defaut dans pylatex tout ce qui concerne latex est efface
    
    # doc.generate_pdf(rapFile, clean_tex=True) # comportement en routine, avec False en mode dev/debug
    # OK sans SVG doc.generate_pdf(rapFile, clean_tex=False)
    # pas de chance !! doc.generate_pdf(rapFile, clean_tex=False,compiler="pdflatex  --shell-escape")
    
    if not os.path.isdir(output_dir):
        os.makedirs(output_dir)
    
    texFile = reportFile + ".tex"
    if (os.path.isfile(texFile)) :
        os.remove(texFile)
    
    pdfFile = reportFile + ".pdf"
    if (os.path.isfile(pdfFile)) :
        os.remove(pdfFile)
    
    current_dir = os.getcwd()
    try:
        os.chdir(output_dir)
        tex_filename = os.path.basename(reportFile)

        # Generating latex file
        doc.generate_tex(tex_filename)

        # LaTeX compilation
        cmd = f"pdflatex --shell-escape -interaction=nonstopmode {tex_filename}"
        if mode == "clean":
            cmd += " > /dev/null"
        os.system(cmd)
    finally:
        os.chdir(current_dir)
    
    # Cleaning auxilares files
    if mode=="clean" :
        if os.path.isfile(reportFile+'.aux') :
            os.remove(reportFile+'.aux')
        if os.path.isfile(reportFile+'.log') :
            os.remove(reportFile+'.log')
    #       if os.path.isfile(reportFile+'.tex') :
    #          os.remove(reportFile+'.tex')
    
    # Ending message
    if (os.path.isfile(pdfFile)) :
        print('Report file is ' + reportFile + ".pdf")
    else :
        print('Probably a LateX error.')


def generate_report(computed_data: ComputedData, config:Config, mode="unset"):
    
    print("\n=================================================================")
    print(" Report Generation")
    print("=================================================================")
    
    # 3 report types are considered. 
    # Full report have an original layout. Pretty but inappropiate for pdf2word conversion.
    # They will print all considered data and needs discretization process: Full log verbosity. Orbkit calculations. 
    # SI mode will discard the layout. Better for the Supplementary inofrmation generation througth a pdf 2word conversion
    # SI mode will also not print the Fukui values and pictures, Analysis populations, Excited states dipoles. 
    # text mode reports are the most simple ones and discard all discretization pictures and calculations
    # Based on the SI mode, we remove the FMO, EDD pictures, CDFT and Charge transfer data.
    report_type = config.output.verbosity
    
    if config.logging.level != "debug":
        mode = "clean"

    # Get output_dir
    designated_name = config.output.molecule_designated_name
    output_dir = os.path.join(config.output.output_path, designated_name)
    if not output_dir.endswith(os.sep):
        output_dir += os.sep

    # Report file
    reportName = f"{sanitize_filename(designated_name)}_{sanitize_filename(report_type)}_report.txt"
    reportFile = output_dir + reportName
    
    config_output: OutputInclude = config.output.include
    
    # Generate Document (LaTeX for now)
    doc = generate_empty_document(report_type)
    
    # Fill Logfiles Details Section
    fill_logfiles_details_section(doc, computed_data, config)
    
    # Fill Molecule Section
    fill_molecule_section(doc, output_dir, computed_data, designated_name, report_type, config_output)
    
    # Fill Computationals Details Section
    if config_output.computational_details:
        fill_computational_details_section(doc, computed_data)
    
    # Fill Wavefunction Section
    fill_wavefunction_section(doc, output_dir, computed_data, report_type, config_output)
    
    # Fill Frequencies Section
    fill_frequencies_section(doc, computed_data, config_output)
    
    # Fill NMR Section
    # TODO : fill_NMR_section(doc, computed_data, report_type)

    # Fill Reactivity Section
    fill_reactivity_section(doc, output_dir, computed_data, report_type, config_output)
    
    # Fill Excited States Section
    fill_excited_states_section(doc, output_dir, computed_data, report_type, config_output)
    
    # Fill Optimized Excited States Section
    fill_optimized_excited_states_section(doc, output_dir, computed_data, report_type, config, config_output)
    
    # Optionally fill with a new section for the additional molecule representations
    if config_output.molecule.molecule_representation:
        fill_additional_molecule_representations_section(doc, computed_data)
    
    # Optionally fill with a new section for the additional Atomic Coordinates
    if config_output.molecule.atomic_coordinates:
        fill_atomic_coordinates_section(doc, computed_data)
    
    # Generate Report Document (LaTeX for now)
    render_report_document(reportFile, output_dir, doc, mode)